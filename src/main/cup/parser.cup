package lyc.compiler;

import java_cup.runtime.*;
import java.util.ArrayList;
import lyc.compiler.model.*;
import lyc.compiler.files.SymbolHashTableGenerator;
import lyc.compiler.files.IntermediateCodeGenerator;
import lyc.compiler.errors.ErrorHandling;

class Parser;

parser code {:
    public int errorCount = 0;
    public boolean syntaxErrors;
    public ArrayList<String> id_list = new ArrayList();

    public void syntax_error(Symbol current_token) {
        report_error(
            ErrorHandling.formatError(
                "Syntax",
                "at line " + (current_token.left + 1) + ", column " + current_token.right + "\n"
            ), null
        );
    }
:};


// -- Terminales -- //
terminal SymbolHashTableGenerator.VariableTypes TIPO;

terminal ID;
terminal CTE_INT;
terminal CTE_FLOAT;
terminal CTE_STRING;

terminal OP_MENOS;
terminal OP_MAS;
terminal OP_MULT;
terminal OP_DIV;
terminal OP_ASIG;

terminal COMA;
terminal DOS_PUNTOS;
terminal PUNTO_COMA;

terminal COMP_EQ;
terminal COMP_DIST;
terminal COMP_MAYOR;
terminal COMP_MENOR;
terminal COMP_MAYOR_EQ;
terminal COMP_MENOR_EQ;

terminal ABRE_LLAVE;
terminal CIERRA_LLAVE;
terminal ABRE_PAR;
terminal CIERRA_PAR;
terminal ABRE_LISTA;
terminal CIERRA_LISTA;

terminal OP_AND;
terminal OP_OR;
terminal OP_NOT;
terminal COND_IF;
terminal COND_ELSE;
terminal CICLO;
terminal INIC_VARS;

terminal LEER_TECLADO;
terminal MOSTRAR_PANTALLA;
terminal FUNC_INDICE;
terminal FUNC_CONCAT;


// -- No Terminales -- //
non terminal asm;
non terminal programa;
non terminal sentencia;
non terminal asignacion;
non terminal iteracion;
non terminal seleccion;
non terminal condicion;
non terminal conjuncion;
non terminal termino_log;
non terminal comparacion;
non terminal argumentos;
non terminal interna_call;
non terminal interna_id;
non terminal args_lista;
non terminal declaracion;
non terminal decl_lista;
non terminal var_lista;

non terminal String constant;
non terminal String comparador;

non terminal SymbolHashTableGenerator.VariableTypes expresion;
non terminal SymbolHashTableGenerator.VariableTypes termino;
non terminal SymbolHashTableGenerator.VariableTypes factor;


// -- Start Symbol -- //
start with asm;


// -- Reglas -- //
asm       ::= programa  {: RESULT = errorCount; :}
            ;
programa  ::= sentencia
            | programa sentencia
            ;
sentencia ::= asignacion PUNTO_COMA
            | declaracion PUNTO_COMA
            | interna_call PUNTO_COMA
            | iteracion
            | seleccion
            ;
asignacion ::= ID:id OP_ASIG expresion  {: IntermediateCodeGenerator.insert("=", id.toString()); :}
            ;
iteracion ::= CICLO ABRE_PAR condicion CIERRA_PAR ABRE_LLAVE programa CIERRA_LLAVE {: :}
            ;
seleccion ::= COND_IF ABRE_PAR condicion CIERRA_PAR ABRE_LLAVE programa CIERRA_LLAVE  {: IntermediateCodeGenerator.update_to_one_more(); :}
            | COND_IF ABRE_PAR condicion CIERRA_PAR ABRE_LLAVE programa CIERRA_LLAVE COND_ELSE  {:
                IntermediateCodeGenerator.insert("BI");
                IntermediateCodeGenerator.move();
                IntermediateCodeGenerator.update_to_one_more();
                IntermediateCodeGenerator.stack_current();
            :}  ABRE_LLAVE programa CIERRA_LLAVE {: IntermediateCodeGenerator.update_to_one_more(); :}
            ;
condicion ::= condicion OP_OR  {: IntermediateCodeGenerator.invertCMP(); :}  conjuncion  {:
                // Avanzamos una celda, actualizamos la celda de la primer comparacion con el inicio del bloque verdadero y apilamos la segunda comparacion. //
                IntermediateCodeGenerator.move(); 
                IntermediateCodeGenerator.update_to_one_more();
                IntermediateCodeGenerator.stack_current();
            :}            // Apila la celda de la segunda comparacion del and (si es que hay uno) o la comparacion sola. //
            | conjuncion  {: IntermediateCodeGenerator.stack_and_move(); :}
            ;
                           // Apila la celda antes del and. //
conjuncion ::= conjuncion  {: IntermediateCodeGenerator.stack_and_move(); :}  OP_AND termino_log
            |  termino_log
            ;
termino_log ::= comparacion
            |   OP_NOT termino_log {: IntermediateCodeGenerator.invertCMP(); :}
            |   ABRE_PAR condicion CIERRA_PAR
            ;
comparacion ::= expresion comparador:cmp expresion  {: IntermediateCodeGenerator.insert("CMP", cmp); IntermediateCodeGenerator.saveLastCMP(); :}
            ;
comparador ::= COMP_EQ        {: RESULT = "BNE"; :}
            |  COMP_DIST      {: RESULT = "BEQ"; :}
            |  COMP_MAYOR     {: RESULT = "BLE"; :}
            |  COMP_MENOR     {: RESULT = "BGE"; :}
            |  COMP_MAYOR_EQ  {: RESULT = "BLT"; :}
            |  COMP_MENOR_EQ  {: RESULT = "BGT"; :}
            ;
expresion ::= expresion:expr OP_MAS termino:term    {:
                if (expr != null && term != null) {
                    if (expr == term) { IntermediateCodeGenerator.insert("+"); }
                    else { 
                        System.err.println(ErrorHandling.formatError("Semantic", "No se puede sumar un \"" + expr.name() + "\" con un \"" + term.name() + "\"."));
                        errorCount++;
                    }
                }
            :}
            | expresion:expr OP_MENOS termino:term  {:
                if (expr != null && term != null) {
                    if (expr == term) { IntermediateCodeGenerator.insert("-"); }
                    else { 
                        System.err.println(ErrorHandling.formatError("Semantic", "No se puede restar un \"" + expr.name() + "\" con un \"" + term.name() + "\"."));
                        errorCount++;
                    }
                }
            :}
            | termino:term  {: RESULT = term; :}
            ;
termino   ::= termino:term OP_MULT factor:fact  {:
                if (term != null && fact != null) {
                    if (term == fact) { IntermediateCodeGenerator.insert("*"); }
                    else { 
                        System.err.println(ErrorHandling.formatError("Semantic", "No se puede multiplicar un \"" + term.name() + "\" con un \"" + fact.name() + "\"."));
                        errorCount++;
                    }
                }
            :}
            | termino:term OP_DIV factor:fact  {:
                if (term != null && fact != null) {
                    if (term == fact) { IntermediateCodeGenerator.insert("/"); } 
                    else { 
                        System.err.println(ErrorHandling.formatError("Semantic", "No se puede dividir un \"" + term.name() + "\" con un \"" + fact.name() + "\"."));
                        errorCount++;
                    }
                }
            :}
            | factor:fact  {: RESULT = fact; :}
            ;
factor    ::= ID:id  {:
                if (SymbolHashTableGenerator.variableExists(id.toString())) {
                    IntermediateCodeGenerator.insert(id.toString());
                    RESULT = SymbolHashTableGenerator.variableType(id.toString());
                } else {
                    System.err.println(ErrorHandling.formatError("Semantic", "Variable \"" + id.toString() + "\" no fue previamente declarada."));
                    errorCount++;
                }
            :}
            | OP_MENOS ID:id  {:
                if (SymbolHashTableGenerator.variableExists(id.toString())) { 
                    if (SymbolHashTableGenerator.variableType(id.toString()) != SymbolHashTableGenerator.VariableTypes.STRING) {
                        IntermediateCodeGenerator.insert('-' + id.toString());
                        RESULT = SymbolHashTableGenerator.variableType(id.toString());
                    } else {
                        System.err.println(ErrorHandling.formatError("Semantic", "Variable \"" + id.toString() + "\" no puede ser negativa porque es de tipo \"string\"."));
                        errorCount++;
                    }
                } else {
                    System.err.println(ErrorHandling.formatError("Semantic", "Variable \"" + id.toString() + "\" no fue previamente declarada."));
                    errorCount++;
                }
            :}
            | constant:cte           {: IntermediateCodeGenerator.insert(cte);  RESULT = SymbolHashTableGenerator.variableType(cte); :}
            | OP_MENOS constant:cte  {: 
                if (SymbolHashTableGenerator.variableType(cte) != SymbolHashTableGenerator.VariableTypes.STRING) {
                    IntermediateCodeGenerator.insert('-' + cte);
                    RESULT = SymbolHashTableGenerator.variableType(cte);
                } else {
                        System.err.println(ErrorHandling.formatError("Semantic", "Constante \"" + cte + "\" no puede ser negativa porque es de tipo \"string\"."));
                        errorCount++;
                }
            :}
            | ABRE_PAR expresion:expr CIERRA_PAR  {: RESULT = expr; :}
            | interna_call
            ;
constant  ::= CTE_INT:cte     {: RESULT = cte.toString(); :}
            | CTE_FLOAT:cte   {: RESULT = cte.toString(); :}
            | CTE_STRING:cte  {: RESULT = cte.toString(); :}
            ;
interna_call ::= interna_id ABRE_PAR argumentos CIERRA_PAR {: :}
            ;
interna_id ::= MOSTRAR_PANTALLA {: :}
            |  LEER_TECLADO {: :}
            |  FUNC_INDICE {: :}
            |  FUNC_CONCAT {: :}
            ;
argumentos ::= factor {: :}
            |  argumentos COMA factor {: :}
            |  argumentos COMA ABRE_LISTA args_lista CIERRA_LISTA {: :}
            ;
args_lista ::= factor {: :}
            |  args_lista COMA factor {: :}
            ;
declaracion ::= INIC_VARS ABRE_LLAVE decl_lista CIERRA_LLAVE {: :}
            ;
decl_lista ::= var_lista DOS_PUNTOS TIPO:type PUNTO_COMA {:
                    id_list.forEach(id -> SymbolHashTableGenerator.addVariable(id, type));
                    id_list = new ArrayList();
                :}
            |  decl_lista var_lista DOS_PUNTOS TIPO:type PUNTO_COMA {:
                    id_list.forEach(id -> SymbolHashTableGenerator.addVariable(id, type));
                    id_list = new ArrayList();
                :}
            ;
var_lista ::= ID:id {: id_list.add(id.toString()); :}
            | var_lista COMA ID:id {: id_list.add(id.toString()); :}
            ;
